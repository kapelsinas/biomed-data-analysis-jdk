---
title: "Praktinė užduotis Nr. 3"
author: "Jaroslav Rutkovskij, Danielė Stasiūnaitė, Karolis Augustauskas (JDK)"
date: "`r format(Sys.time(), '%d/%m/%y')`"
output:
  pdf_document: default
  html_document:
    df_print: paged
subtitle: Hipotezių testavimas
---

```{r Figure_size, warning=FALSE, include=FALSE}
knitr::opts_chunk$set(fig.height = 13, fig.width = 16)
```

```{r Preparations, warning=FALSE, include=FALSE}
library(pacman)
p_load(dplyr, ggplot2, reshape2, reshape, data.table, stringi, stringr,huxtable)
```

```{r Data_access, warning=FALSE, include=FALSE}
beta <- readRDS("data/dat8.Rds")               # Modification value matrix
pData_col <- readRDS("data/pData.Rds")         # Sample (column) matrix
annot_row <- readRDS("data/annotation.Rds")    # Position (row) matrix
samples <- read.csv("samples2.csv")

colnames(beta) <- samples$graph_name[match(colnames(beta), samples$Basename)]
```

# 1. Statistinis hipotezių testavimas vidurkių palyginimui

Neretai atliekant biomedicininių duomenų analizę, duomenys yra analizuojami
juos suskirstant į tam tikras grupes ir tiriant, kaip skiriasi atliekamų
statistinių testų rezultatai tarp skirtingų grupių. Grupės gali būti sudaromos
pagal požymius, kurie yra žinomi iš tyrime analizuojamų mėginių aprašymo
lentelių.
Pavyzdžiui, turint sudarytas mėginių aprašymo lenteles galima sudaryti grupes:
- Viršsvorio turinčių ir viršsvorio neturinčių tiriamųjų grupės;
- Rūkančių ir nerūkančių tiriamųjų grupės;
- Vyrų ir moterų grupės;
- Sveikų ir sergančių tiriamųjų grupės.
- Ir pan.

Iš šioje užduotyje nagrinėjamo straipsnio, kuriame buvo tiriamos moterų žarnų
biopsijos, buvo gauta mėginius aprašanti lentelė, kurią peržiūrėjus buvo
galima sudaryti grupes pagal kelis požymius:
- Žarnų polipų turinčių ir polipų neturinčių moterų grupės;
- Moterų, kurioms yra nuo 50 iki 65 metų, grupė ir moterų, kurioms yra nuo 65
iki 80 metų, grupė;
- Aspiriną ilgą laiką vartojančių ir nevartojančių moterų grupės.

Pirmoje užduoties dalyje pasirinkta suskirstyti mėginius į grupes pagal aspirino
vartojimą ir nevartojimą. Antroje praktinėje užduotyje dalis mėginių buvo
pašalinti, nes jie neteikė vertingos informacijos, todėl šioje praktinėje
užduotyje analizuojamų mėginių kiekis yra mažesnis (96 mėginiai iš 124 mėginių).

Žemiau esančioje horizontalioje stulpelinėje diagramoje vaizduojama, kiek
mėginių sudarė kievieną grupę (aspirino nevartojančių grupė ir aspiriną
vartojančių grupė) prieš atliekant antrąją praktinę užduotį, kai buvo turimi
124 mėginiai, bei stulpeliai, kuriuose vaizduojami mėginių kiekiai grupėse
po mėginių pašalinimo (likus 96 mėginiams):

```{r Aspirin_user/nonuser_selection, fig.width = 4, fig.height = 3, fig.align = "center", warning=FALSE, include=FALSE}
# Extracting data frame rows that describe aspirin non-users:
aspirin_nonusers <- samples[samples$aspirin == 'nonuser', ]$graph_name

# Extracting data frame rows that describe aspirin longterm users:
aspirin_users <- samples[samples$aspirin == 'longterm', ]$graph_name

# Extracting matrix columns that store aspirin non-user modification values
# (from beta matrix):
beta_nonusers <- beta[, colnames(beta) %in% aspirin_nonusers]

# Extracting matrix columns that store aspirin non-user modification values
# (from beta matrix):
beta_users <- beta[, colnames(beta) %in% aspirin_users]

group_counts <- data_frame(aspirin = c("Aspirin nonusers (from 124 samples)",
     "Aspirin users (from 124 samples)", "Aspirin nonusers (from 96 samples)",
     "Aspirin users (from 96 samples)"), 
                           count = c(length(aspirin_nonusers),
     length(aspirin_users), length(colnames(beta_nonusers)),
     length(colnames(beta_users))))

p0 <- ggplot(group_counts, aes(x = aspirin, y = count)) +
        geom_bar(stat = "identity", color = "#31000d", fill = "#66001a") +
        geom_text(aes(label = count), hjust = -0.5, size = 4, fontface = "bold") +
        labs(x = "Groups", y = "Count",
             title = "Aspirin nonusers and users") +
        scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) + 
        coord_flip() +
        ylim(c(0, 80)) +
        theme(axis.text.y = element_text(hjust = 0.5, colour = "black"),
              axis.text.x = element_text(colour = "black"),
              plot.title = element_text(hjust = 0.5, face = "bold"),
              panel.background = element_rect(colour = "#31000d", size = 0.5,
                                              fill = "#ffeff4",
                                              linetype = "solid"),
              panel.grid.major = element_line(size = 0.1, linetype = 'dashed',
                                              colour = "#66001a"), 
              panel.grid.minor = element_line(size = 0.1, linetype = 'dashed',
                                              colour = "#66001a"))
print(p0)
```
Suskirsčius mėginius į grupes buvo tikrinama, kaip skiriasi visų DNR pozicijų
modifikacijos reikšmių vidurkiai tarp sudarytų aspirino nevartojančių ir
aspiriną vartojančių moterų grupių. Šis palyginimas atliktas, pasinaudojus
svarbiu statistikoje taikomu ***t-testu***, kuris šiuo atveju bando nustatyti,
ar modifikacijos reikšmių vidurkiai skirtingose DNR pozicijose sutampa.

Atlikus abiejų grupių modifikacijos reikšmių vidurkių pozicijose palyginimą,
yra grąžinamos specialios reikšmės (p vertės), kurios leidžia padaryti išvadą,
ar susietų grupių modifikacijos reikšmių vidurkiai skiriasi reikšmingai.
Kitaip tariant, šio testo rezultatas padeda įvertinti, ar aspirino vartojimas
ir nevartojimas įtakoja DNR modifikacijų reikšmes.

# T.test. Reikalingas trumpas paaiškinimas, kodėl jį atliekam ir ką
# jis duoda (aiškinti kaip medikui, o ne kaip dėstytojui).

# Efekto dydžio skaičiavimas. Truputį aprašyti, kas tas efekto dydis,
# kodėl jį atliekam ir nurodyti, kad yra toks Cohen's d testas, leidžiantis
# apskaičiuoti efekto dydį. Jokių būdu neaprašinėti techniškai, bet aiškiai
# ir suprantamai, paaiškinant pagrindinę esmę.

```{r T_test_effect_size_calculations, warning=FALSE, include=FALSE}
# Creating an empty matrixes that will store p values and effect sizes
# for each position:
pvalues <- matrix(NA,nrow = nrow(beta), ncol=2)
effect_sizes <- matrix(NA,nrow=nrow(beta), ncol=2)

# Running a loop that performs t-test, effect size calculations and appends
# p-values, effect size values into matrixes:
sprintf("Start time: %s", format(Sys.time(), "%D %H:%M:%S"))
for (row in 1:nrow(beta)) {
  vec1 <- c(beta_nonusers[row, ])
  vec2 <- c(beta_users[row, ])
  rowname <- rownames(beta_nonusers)[row]
  
  row_pvalue <- c(rowname, t.test(vec1, vec2)$p.value)
  effect_size <- c(rowname, (mean(vec1) - mean(vec2)) /
                     sqrt((var(vec1) + var(vec2)) / 2))
  # if (row %% 10000 == 0) {
  #   print(row)
  # }
  # 
  effect_sizes[row,] <- effect_size
  pvalues[row,] <- row_pvalue
}
sprintf("End time: %s", format(Sys.time(), "%D %H:%M:%S"))

colnames(pvalues) <- c("Position", "P-value")
colnames(effect_sizes) <- c("Position", "Effect size")

effect_sizes <- as.data.frame(effect_sizes)
pvalues <- as.data.frame(pvalues)

# saveRDS(effect_sizes, file='effect_sizes.rds')
# saveRDS(pvalues, file="p_values.rds")
```

# Paaiškinti, ką atvaizduoja ši histograma, interpretuoti ją ir panašiai.
Žemiau pateikiamoje histogramoje yra vaizduojamas gautų *p* verčių
pasiskirstymas. Jeigu *p* reikšmės yra mažesnės už *0.05*, tada yra atmetama
hipotezė, jog grupių vidurkiai yra lygūs - yra daroma išvada, kad 
modifikacijos reikšmių vidurkiai tarp skirtingų grupių yra reikšmingi.

Svarbu paminėti, kad šiuo atveju modifikacijos reikšmių skaičius grupėse yra
skirtingas, todėl modifikacijos reikšmių vidurkiai nesutaps. Dėl šios
priežasties **Papildomos užduotys** dalyje yra sulyginamas mėginių skaičius
grupėse ir pakartojamas *t testas*, modifikacijos reikšmių vidurkiams grupėse
palyginti.

Vaizduojama histograma rodo, kad buvo gautas didelis skaičius *p* verčių,
kurios buvo mažesnės už 0.05. Reikšmių, kurios būtų didesnės už 0.05, buvo
nustatyta mažiau. Taip pat didėjančių *p* verčių skaičius mažėjo, stebint
didesnius *p* verčių kiekius ties 0.125, 0.225, 0.35, 0.55, 0.9 ir 0.975
*p* vertėmis:

```{r P_value_histogram, fig.align="center", fig.height=3, fig.width=5, echo=FALSE, warning=FALSE}
values <- as.numeric(pvalues$P_value)
p_df <- data.frame(positions = c(pvalues$Position), pvals = values)

p1 <- ggplot(p_df, aes(x = pvals)) + 
        geom_histogram(binwidth = 0.025, color = "#00004d", fill = "#2f4581") +
        geom_vline(xintercept = 0.05, color = "red", size = 0.7,
                   linetype = "longdash") +
        geom_vline(xintercept = c(0.125, 0.225, 0.35, 0.55, 0.9, 0.975),
                   color = "#e6b300", size = 0.5, linetype = "longdash") +
        labs(x = "P value", y = "Count",
             title = "P-value distribution histogram") +
        scale_x_continuous(breaks = seq(0, 1, by = 0.05)) +
        annotate("text", x = 0.2, y = 400, label = stringr::str_wrap("Line
                 indicating 0.05 p value break", width = 20), size = 3,
                 color = "red", fontface = 4) +
        annotate("text", x = 0.725, y = 400, label = stringr::str_wrap("Lines
                 indicating slightly higher certain p value counts",
                 width = 25), size = 3, color = "#e6b300", fontface = 4) +
        theme(axis.text.x = element_text(angle = 45, vjust = 0.5,
                                         colour = "black"),
              plot.title = element_text(hjust = 0.5, face = "bold"),
              panel.background = element_rect(colour = "#05076a", size = 0.5,
                                              fill = "#eaeafd",
                                              linetype = "solid"),
              panel.grid.major = element_line(size = 0.05, linetype = 'dashed',
                                              colour = "#05076a"), 
              panel.grid.minor = element_line(size = 0.05, linetype = 'dashed',
                                              colour = "#05076a"))
print(p1)
```

# Pakomentuoti, koks veiksmas buvo padarytas toliau, kodėl jis buvo daromas bei
# koks rezultatas buvo gautas.

```{r Min_p_value_visualization, fig.align="center", fig.height=4, fig.width=5, echo=FALSE, warning=FALSE}
# Ordering a p-value dataframe and extracting 5 rows with the lowest p-value:
#min_Ps <- p_df[order(p_df$pvals),][1:5,]

# Determining position names that have the lowest p-values:
position_names <- p_df[order(p_df$pvals),][1:5,]$positions

nonuser_len <- length(colnames(beta_nonusers))
user_len <- length(colnames(beta_users))

# Creating dataframes with modification values of 5 positions (cg01760763,
# cg20768358, cg07179016, cg14510359, cg04083753):
anon_users <- beta_nonusers[position_names, ] %>%
                `colnames<-`(c(rep("Aspirin nonusers", nonuser_len))) %>%
                melt()

a_users <- beta_users[position_names, ] %>%
              `colnames<-`(c(rep("Aspirin users", user_len))) %>%
              melt()

# Combining two dataframes (of aspirin non-users and aspirin users) into one:
group_modifications <- rbind(anon_users, a_users) %>%
                          setNames(., c("Position", "User_nonuser",
                                   "Modification_value"))

p2 <- ggplot(group_modifications, aes(x = User_nonuser, y = Modification_value,
                                      color = Position)) +
        geom_point() +
        scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) + 
        labs(title = "DNA modification values",
             subtitle = "5 positions with the lowest p values",
             x = "Aspirin user/non-user", y = "Modification value") +
        facet_grid(. ~ Position) +
        theme(axis.text.x = element_text(vjust = 0.5, size = 8,
                                         colour = "black"),
              plot.title = element_text(hjust = 0.5, face = "bold"),
              plot.subtitle = element_text(hjust = 0.5, face = "bold"),
              panel.background = element_rect(colour = "#05076a", size = 0.5,
                                              fill = "#eaeafd",
                                              linetype = "solid"),
              panel.grid.major = element_line(size = 0.08, linetype = 'dashed',
                                              colour = "#05076a"), 
              panel.grid.minor = element_line(size = 0.08, linetype = 'dashed',
                                              colour = "#05076a"),
              strip.background = element_rect(fill = "#2f4581"),
              strip.text = element_text(color = "white", face = "bold"),
              legend.position = "none")

print(p2 + scale_color_brewer(palette = "Set1"))
```
???????
```{r Chromosome_manhattan_plot, echo=FALSE, warning=FALSE}
Pvalues <- readRDS("data/p_values.rds")
Pval <- Pvalues %>% setNames(., c("Position", "P_value"))

#positions_chr <- annot_row[annot_row$chr == "chr1", ]$Name
#chr1 <- Pval[Pval$Position %in% positions_chr,]
#chr1

#ch1 <- data.frame(CHR = c(rep(1, length(annot_row[annot_row$chr == "chr1", ]$Name))),
#                  P = chr1$P_value)
#annot_row[annot_row$chr == "chr1", ]
#colnames(annot_row)
```

# 2. Daugkartinio testavimo p verčių korekcija

```{r P_value_corrections, echo=FALSE, message=FALSE, warning=FALSE}
fdr <- p.adjust(Pval$P_value, method = "fdr", n = length(Pval$P_value))
bf <- p.adjust(Pval$P_value, method = "bonferroni", n = length(Pval$P_value))

p_corr <- data.frame(Position = Pval$Position, No_correction = Pval$P_value,
                     FDR = fdr, Bonferroni = bf)

positions <- data.table(correction = c("Be korekcijos","FDR","Bonferroni"),
   position_count = c(length(rownames(p_corr[p_corr$No_correction <= 0.05, ])),
                      length(rownames(p_corr[p_corr$FDR <= 0.05, ])),
                      length(rownames(p_corr[p_corr$Bonferroni <= 0.05, ]))))


positions                                                                                           %>%
      as_huxtable()                                                                                 %>%
      set_bold(1, everywhere, TRUE)                                                                 %>%
      set_all_borders(1)                                                                            %>%
      map_text_color(everywhere, "position_count",      by_colorspace("navy", "red", "darkgreen"))  %>%
      map_italic(everywhere, "correction",        by_regex("Merc.*" = TRUE))                        %>%
      set_bold(1, everywhere, TRUE)                                                                 %>%
      set_background_color(1:1, everywhere , "lightgreen")                                          %>%
      set_align(1,1, "center")

  
```

# 3. Gene Ontology Enrichment analizė
# Genų sąrašas pozicijoms, turinčioms patikimas p vertes po FDR korekcijos.

```{r GO_analysis_selected_genes_by_p, warning=FALSE, include=FALSE}
# Extracting 'UCSC_RefGene_Name' column values of positions that have a p value
# which is lower or equal to 0.05 after performing FDR correction:
selected_pos <- p_corr[p_corr$FDR <= 0.05, 1] %>% 
                  annot_row[.,]
fgenes <- c(unique(selected_pos$UCSC_RefGene_Name)) %>%
               stri_remove_empty(., na_empty = FALSE)

# Handling lines with gene name repetitions:
modify_lines <- function(x) {
      if (grepl(";", x) == TRUE) {
        smatch <- str_match(x, pattern = regex("([a-zA-Z0-9]*);",
                                               ignore_case = T))
        smatch[1, 1] %>% substr(., 1, nchar(.) - 1)
      } else { x }
}

# Making a unique "foreground" gene name list:
flist <- lapply(fgenes, modify_lines)
fgene_list <- data.table(Genes = unique(unlist(flist)))

write.table(fgene_list, file = "foreground_gene_list.txt", quote = FALSE,
            col.names = FALSE, row.names = FALSE)
```

# 4. Visus aukščiau aprašytus žingsnius pakartokite ieškodami pozicijų susijusių su amžiumi.

```{r 4.1, warning=FALSE, include=FALSE }
# Using linear models to create two models to control "outsider" effects.
mod0 <- lm(age ~ aspirin + clonic_location, data = samples)
mod1 <- lm(age ~ aspirin + clonic_location + polyp, data = samples)

res <- anova(mod0, mod1)

```

# Pilnas genų sąrašas
# Įskaitomi visi genai, nepaisant to, kiek patikimos yra juos atitinkančios
# pozicijos.

```{r GO_analysis_all_genes, warning=FALSE, include=FALSE}
# Extracting 'UCSC_RefGene_Name' column values for the entire positions:
bgenes <- c(unique(annot_row$UCSC_RefGene_Name)) %>%
               stri_remove_empty(., na_empty = FALSE)

# Making a unique "background" gene name list:
blist <- lapply(bgenes, modify_lines)
bgene_list <- data.table(Genes = unique(unlist(blist)))

write.table(bgene_list, file = "background_gene_list.txt", quote = FALSE,
            col.names = FALSE, row.names = FALSE)
```
