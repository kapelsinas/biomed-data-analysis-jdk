---
title: "Praktinė užduotis Nr. 3"
author: "Jaroslav Rutkovskij, Danielė Stasiūnaitė, Karolis Augustauskas (JDK)"
date: "`r format(Sys.time(), '%d/%m/%y')`"
output:
  pdf_document: default
  html_document:
    df_print: paged
subtitle: Hipotezių testavimas
---

```{r Figure_size, message=FALSE, warning=FALSE, include=FALSE}
knitr::opts_chunk$set(fig.height = 13, fig.width = 16)
```

```{r Preparations, message=FALSE, warning=FALSE, include=FALSE}
library(pacman)
p_load(dplyr, ggplot2, reshape2, reshape, data.table, stringi, stringr,
       huxtable, VennDetail)
```

```{r Data_access, message=FALSE, warning=FALSE, include=FALSE}
beta <- readRDS("dat8.Rds")               # Modification value matrix
pData_col <- readRDS("pData.Rds")         # Sample (column) matrix
annot_row <- readRDS("annotation.Rds")    # Position (row) matrix
samples <- read.csv("samples2.csv") # POS = BP, SNP - nėra! Išsirinkti tą CHR, kuri atrodo įdomiausiai, lengviau interpretuoti.

colnames(beta) <- samples$graph_name[match(colnames(beta), samples$Basename)]

annot_row[annot_row$chr == "chr1",]
```

# Pagrindinės užduotys
## 1. Statistinis hipotezių testavimas vidurkių palyginimui

Neretai atliekant biomedicininių duomenų analizę, duomenys yra analizuojami
juos suskirstant į tam tikras grupes ir tiriant, kaip skiriasi atliekamų
statistinių testų rezultatai tarp skirtingų grupių. Grupės gali būti sudaromos
pagal požymius, kurie yra žinomi iš tyrime analizuojamų mėginių aprašymo
lentelių.
Pavyzdžiui, turint sudarytas mėginių aprašymo lenteles galima sudaryti grupes:
- Viršsvorio turinčių ir viršsvorio neturinčių tiriamųjų grupės;
- Rūkančių ir nerūkančių tiriamųjų grupės;
- Vyrų ir moterų grupės;
- Sveikų ir sergančių tiriamųjų grupės;
- Ir pan.

Iš šioje užduotyje nagrinėjamo straipsnio, kuriame buvo tiriamos moterų žarnų
biopsijos, buvo gauta mėginius aprašanti lentelė, kurią peržiūrėjus buvo
galima sudaryti grupes pagal kelis požymius:
- Žarnų polipų turinčių ir polipų neturinčių moterų grupės;
- Moterų, kurioms yra nuo 50 iki 65 metų, grupė ir moterų, kurioms yra nuo 65
iki 80 metų, grupė;
- Aspiriną ilgą laiką vartojančių ir nevartojančių moterų grupės.

Pirmoje užduoties dalyje pasirinkta suskirstyti mėginius į grupes pagal aspirino
vartojimą ir nevartojimą. Antroje praktinėje užduotyje dalis mėginių buvo
pašalinti, nes jie neteikė vertingos informacijos, todėl šioje praktinėje
užduotyje analizuojamų mėginių kiekis yra mažesnis (96 mėginiai iš 124 mėginių).

Žemiau esančioje horizontalioje stulpelinėje diagramoje vaizduojama, kiek
mėginių sudarė kievieną grupę (aspirino nevartojančių grupė ir aspiriną
vartojančių grupė) prieš atliekant antrąją praktinę užduotį, kai buvo turimi
124 mėginiai, bei stulpeliai, kuriuose vaizduojami mėginių kiekiai grupėse
po mėginių pašalinimo (likus 96 mėginiams):

```{r Aspirin_user/nonuser_selection, fig.align="center", fig.height=3, fig.width=4, message=FALSE, warning=FALSE, include=FALSE}
# Extracting data frame rows that describe aspirin non-users:
aspirin_nonusers <- samples[samples$aspirin == 'nonuser', ]$graph_name

# Extracting data frame rows that describe aspirin longterm users:
aspirin_users <- samples[samples$aspirin == 'longterm', ]$graph_name

# Extracting matrix columns that store aspirin non-user modification values
# (from beta matrix):
beta_nonusers <- beta[, colnames(beta) %in% aspirin_nonusers]

# Extracting matrix columns that store aspirin non-user modification values
# (from beta matrix):
beta_users <- beta[, colnames(beta) %in% aspirin_users]

group_counts <- data_frame(aspirin = c("Aspirin nonusers (from 124 samples)",
     "Aspirin users (from 124 samples)", "Aspirin nonusers (from 96 samples)",
     "Aspirin users (from 96 samples)"), 
                           count = c(length(aspirin_nonusers),
     length(aspirin_users), length(colnames(beta_nonusers)),
     length(colnames(beta_users))))

p0 <- ggplot(group_counts, aes(x = aspirin, y = count)) +
        geom_bar(stat = "identity", color = "#31000d", fill = "#66001a") +
        geom_text(aes(label = count), hjust = -0.5, size = 4, fontface = "bold") +
        labs(x = "Groups", y = "Count",
             title = "Aspirin nonusers and users") +
        scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) + 
        coord_flip() +
        ylim(c(0, 80)) +
        theme(axis.text.y = element_text(hjust = 0.5, colour = "black"),
              axis.text.x = element_text(colour = "black"),
              plot.title = element_text(hjust = 0.5, face = "bold"),
              panel.background = element_rect(colour = "#31000d", size = 0.5,
                                              fill = "#ffeff4",
                                              linetype = "solid"),
              panel.grid.major = element_line(size = 0.1, linetype = 'dashed',
                                              colour = "#66001a"), 
              panel.grid.minor = element_line(size = 0.1, linetype = 'dashed',
                                              colour = "#66001a"))
print(p0)
```

Suskirsčius mėginius į grupes buvo tikrinama, kaip skiriasi visų DNR pozicijų
modifikacijos reikšmių vidurkiai tarp sudarytų aspirino nevartojančių ir
aspiriną vartojančių moterų grupių. Šis palyginimas atliktas, pasinaudojus
svarbiu statistikoje taikomu ***t-testu***, kuris šiuo atveju tikrina,
ar modifikacijos reikšmių vidurkiai skirtingose DNR pozicijose sutampa.

Atlikus abiejų grupių modifikacijos reikšmių vidurkių pozicijose palyginimą,
yra grąžinamos specialios reikšmės (p vertės), kurios leidžia padaryti išvadą,
ar susietų grupių modifikacijos reikšmių vidurkiai skiriasi reikšmingai.
***Kitaip tariant***, šio testo rezultatas padeda įvertinti, ar aspirino vartojimas
ir nevartojimas įtakoja DNR modifikacijų reikšmes.

# T.test. Reikalingas trumpas paaiškinimas, kodėl jį atliekam ir ką
# jis duoda (aiškinti kaip medikui, o ne kaip dėstytojui).

# Efekto dydžio skaičiavimas. Truputį aprašyti, kas tas efekto dydis,
# kodėl jį atliekam ir nurodyti, kad yra toks Cohen's d testas, leidžiantis
# apskaičiuoti efekto dydį. Jokių būdu neaprašinėti techniškai, bet aiškiai
# ir suprantamai, paaiškinant pagrindinę esmę.

```{r T_test_effect_size_calculations, message=FALSE, warning=FALSE, include=FALSE}
# Creating an empty matrixes that will store p values and effect sizes
# for each position:
pvalues <- matrix(NA, nrow = nrow(beta), ncol = 2)
effect_sizes <- matrix(NA, nrow = nrow(beta), ncol = 2)

# Running a loop that performs t-test, effect size calculations and appends
# p-values, effect size values into matrixes:
#sprintf("Start time: %s", format(Sys.time(), "%D %H:%M:%S"))

for (row in 1:nrow(beta)) {
  vec1 <- c(beta_nonusers[row, ])
  vec2 <- c(beta_users[row, ])
  rowname <- rownames(beta_nonusers)[row]
  
  row_pvalue <- c(rowname, t.test(vec1, vec2)$p.value)
  effect_size <- c(rowname, (mean(vec1) - mean(vec2)))

  effect_sizes[row, ] <- effect_size
  pvalues[row, ] <- row_pvalue
}

#sprintf("End time: %s", format(Sys.time(), "%D %H:%M:%S"))

colnames(pvalues) <- c("Position", "Pvalue")
colnames(effect_sizes) <- c("Position", "Effect_size")

effect_sizes <- as.data.frame(effect_sizes)
pvalues <- as.data.frame(pvalues)

# saveRDS(effect_sizes, file='effect_sizes.rds')
# saveRDS(pvalues, file="p_values.rds")

# pvalues <- readRDS("p_values.rds")
# effect_sizes <- readRDS("effect_sizes.rds")

#pvalues
#effect_sizes
```

### P verčių histograma

Žemiau pateikiamoje histogramoje yra vaizduojamas gautų *p* verčių
pasiskirstymas. Jeigu *p* reikšmės yra mažesnės už *0.05*, tada yra atmetama
hipotezė, jog grupių vidurkiai yra lygūs - yra daroma išvada, kad 
modifikacijos reikšmių vidurkiai tarp skirtingų grupių yra reikšmingi.

Svarbu paminėti, kad šiuo atveju modifikacijos reikšmių skaičius grupėse yra
skirtingas, todėl modifikacijos reikšmių vidurkiai nesutaps. Dėl šios
priežasties **Papildomos užduotys** dalyje yra sulyginamas mėginių skaičius
grupėse ir pakartojamas *t testas*, modifikacijos reikšmių vidurkiams grupėse
palyginti.

Vaizduojama histograma rodo, kad buvo gautas didelis skaičius *p* verčių,
kurios buvo mažesnės už 0.05. Reikšmių, kurios būtų didesnės už 0.05, buvo
nustatyta mažiau. Taip pat didėjančių *p* verčių skaičius gradualiai mažėjo:

```{r P_value_histogram, echo=FALSE, fig.align="center", fig.height=3, fig.width=5, message=FALSE, warning=FALSE}
values <- as.numeric(pvalues$Pvalue)
p_df <- data.frame(positions = c(pvalues$Position), pvals = values)

p1 <- ggplot(p_df, aes(x = pvals)) + 
        geom_histogram(binwidth = 0.025, color = "#00004d", fill = "#2f4581") +
        geom_vline(xintercept = 0.05, color = "red", size = 0.7,
                   linetype = "longdash") +
        labs(x = "P value", y = "Count",
             title = "P-value distribution histogram") +
        scale_x_continuous(breaks = seq(0, 1, by = 0.05)) +
        annotate("text", x = 0.2, y = 40000, label = stringr::str_wrap("Line
                 indicating 0.05 p value break", width = 20), size = 3,
                 color = "red", fontface = 4) +
        theme(axis.text.x = element_text(angle = 45, vjust = 0.5,
                                         colour = "black"),
              plot.title = element_text(hjust = 0.5, face = "bold"),
              panel.background = element_rect(colour = "#05076a", size = 0.5,
                                              fill = "#eaeafd",
                                              linetype = "solid"),
              panel.grid.major = element_line(size = 0.05, linetype = 'dashed',
                                              colour = "#05076a"), 
              panel.grid.minor = element_line(size = 0.05, linetype = 'dashed',
                                              colour = "#05076a"))
print(p1)
```
### Patikimiausių pozicijų DNR modifikacijos profilis

### Reikia keisti
Žemiau esančiuose grafikuose yra vaizduojami modifikacijos įverčiai 5 pozicijų,
turinčių žemiausias *p* vertes. Kiekviename atskirame grafike yra vaizduojamos
aspirino nevartojančių ir aspiriną vartojančių moterų modifikacijos vertės
atrinktose pozicijose.

Grafikuose galima pastebėti, kad pirmosios pozicijos (cg01760763) modifikacijos
įverčiai yra įvairesni aspiriną vartojančių moterų grupėje. Pirmajame ir
antrajame grafikuose (cg01760763, cg20768358) modifikacijos įverčiai yra
didžiausi. Taip pat iš grafikų galima pastebėti, kad paskutinės pozicijos
(cg04083753) modifikacijos įverčiai yra patys mažiausi.

```{r Min_p_value_visualization, echo=FALSE, fig.align="center", fig.height=3, fig.width=5, message=FALSE, warning=FALSE}
# Ordering a p-value dataframe and extracting 5 rows with the lowest p-value:
#min_Ps <- p_df[order(p_df$pvals),][1:5,]

# Determining position names that have the lowest p-values:
position_names <- p_df[order(p_df$pvals),][1:5,]$positions

nonuser_len <- length(colnames(beta_nonusers))
user_len <- length(colnames(beta_users))

# Creating dataframes with modification values of 5 positions (cg01760763,
# cg20768358, cg07179016, cg14510359, cg04083753):
anon_users <- beta_nonusers[position_names, ] %>%
                `colnames<-`(c(rep("Aspirin nonusers", nonuser_len))) %>%
                melt()

a_users <- beta_users[position_names, ] %>%
              `colnames<-`(c(rep("Aspirin users", user_len))) %>%
              melt()

# Combining two dataframes (of aspirin non-users and aspirin users) into one:
group_modifications <- rbind(anon_users, a_users) %>%
                          setNames(., c("Position", "User_nonuser",
                                   "Modification_value"))

p2 <- ggplot(group_modifications, aes(x = User_nonuser, y = Modification_value,
                                      color = Position)) +
        geom_point() +
        scale_x_discrete(labels = function(x) str_wrap(x, width = 10)) + 
        labs(title = "DNA modification values",
             subtitle = "5 positions with the lowest p values",
             x = "Aspirin nonusers and users", y = "Modification value") +
        facet_grid(. ~ Position) +
        theme(axis.text.x = element_text(vjust = 0.5, size = 8,
                                         colour = "black"),
              plot.title = element_text(hjust = 0.5, face = "bold"),
              plot.subtitle = element_text(hjust = 0.5, face = "bold"),
              panel.background = element_rect(colour = "#05076a", size = 0.5,
                                              fill = "#eaeafd",
                                              linetype = "solid"),
              panel.grid.major = element_line(size = 0.08, linetype = 'dashed',
                                              colour = "#05076a"), 
              panel.grid.minor = element_line(size = 0.08, linetype = 'dashed',
                                              colour = "#05076a"),
              strip.background = element_rect(fill = "#2f4581"),
              strip.text = element_text(color = "white", face = "bold"),
              legend.position = "none")

print(p2 + scale_color_brewer(palette = "Set1"))
```

### Manhattan grafikas septintos chromosomos p vertėms 

```{r Chromosome_manhattan_plot, echo=FALSE, message=FALSE, warning=FALSE}
pvalues

positions_chr <- annot_row[annot_row$chr == "chr1", ]$Name
chr1 <- pvalues[pvalues$Position %in% positions_chr,]
chr1

#ch1 <- data.frame(CHR = c(rep(1, length(annot_row[annot_row$chr == "chr1", ]$Name))),
#                  P = chr1$P_value)
#annot_row[annot_row$chr == "chr1", ]
#colnames(annot_row)
```

### Volcano grafikas visų chromosomų efektų dydžiams ir p vertėms

```{r Chromosome_manhattan_plot, echo=FALSE, message=FALSE, warning=FALSE}
library(ggplot2)


pvalues <- readRDS("p_values.rds")
effect_sizes <- readRDS("effect_sizes.rds")
colnames(pvalues) <- c("Position", "Pvalues")
colnames(effect_sizes) <- c("Position", "Effect_size")

df <- data.frame(P = as.numeric(pvalues$Pvalues),
                 Effect_size = as.numeric(effect_sizes$Effect_size))

p1 <- ggplot(df, aes(Effect_size, -log(P,10))) + # -log10 conversion  
  geom_point(size = 2/5) +
  xlab(expression("log"[2]*"FC")) + 
  ylab(expression("-log"[10]*"FDR"))
p1
```

## 2. Daugkartinio testavimo p verčių korekcija

Neretai tam pačiam duomenų rinkiniui statistiniai testai yra atliekami daug
kartų, tačiau tokiu atveju taikoma 0.05 *p* vertės riba (5%) gali reikšti, jog
tarp atliktų testų gali būti labai daug *false positive* reikšmių.

***False positive*** - tai yra reikšmė, kuri laikoma reikšminga, tačiau iš
tiesų ji nėra reikšminga.

Kitaip tariant *p* reikšmė, padauginta iš 100, nurodo, kokia yra tikimybė
atmesti teisingą hipotezę.

Šioje praktinės užduoties dalyje yra atliekamos *p* reikšmių korekcijos, kurios
pritaikomos tam, jog būtų sumažinta riba, pagal kurią galima spręsti apie
vidurkių reikšmingumą (sumažėtų galimas ***false positive*** reikšmių
procentas), kai tas pats testas yra atliekamas daug kartų.

Žemiau pateikiama lentelė, kurioje pateikiami reikšmingų pozicijų kiekiai
neatlikus *p* verčių korekcijos, pritaikius *FDR* ir *Bonferroni* korekcijas:

```{r P_value_corrections, echo=FALSE, message=FALSE, warning=FALSE}
fdr <- p.adjust(Pval$P_value, method = "fdr", n = length(Pval$P_value))
bf <- p.adjust(Pval$P_value, method = "bonferroni", n = length(Pval$P_value))

p_corr <- data.frame(Position = Pval$Position, No_correction = Pval$P_value,
                     FDR = fdr, Bonferroni = bf)

positions <- data.table(correction = c("No correction","FDR","Bonferroni"),
   position_count = c(length(rownames(p_corr[p_corr$No_correction <= 0.05, ])),
                   length(rownames(p_corr[p_corr$FDR <= 0.05, ])),
                   length(rownames(p_corr[p_corr$Bonferroni <= 0.05, ])))) %>%
   as_huxtable() %>%
   set_bold(1, everywhere, TRUE) %>%
   set_all_borders(1) %>%
   map_text_color(everywhere, "position_count",
                  by_colorspace("navy", "red", "darkgreen")) %>%
   map_italic(everywhere, "correction", by_regex("Merc.*" = TRUE)) %>%
   set_bold(1, everywhere, TRUE) %>%
   set_background_color(1:1, everywhere , "lightgreen") %>%
  set_align(1,1, "center")

align(positions) <- "center"
print(positions)
```
Lentelės duomenys rodo, kad atliekant daugkartinį testavimą, daugiausiai
reikšmingų pozicijų nustatoma, atlikus *p* verčių *FDR* korekciją. Kai
atliekama *p* verčių *FDR* korekcija.

*P* vertės po *FDR* korekcijos interpretuojamos taip:\
*5% REIKŠMINGŲ testų duos false positive rezultatą*.

*P* reikšmės be korekcijos interpretuojamos taip:\
*5% VISŲ testų duos false positive rezultatą*.

## 3. Gene Ontology Enrichment analizė

Atlikus *p* verčių korekciją ir įvertinus, kurios DNR pozicijos turi
statistiškai patikimus modifikacijos įverčių vidurkius, galima analizuoti
atrinktas DNR pozicijas, pasinaudojus specialiu **GOrilla** įrankiu, kuris
padeda daryti įvairias išvadas apie konkrečiose pozicijose esančius genus.

```{r GO_analysis_selected_genes_by_p, message=FALSE, warning=FALSE, include=FALSE}
# Extracting 'UCSC_RefGene_Name' column values of positions that have a p value
# which is lower or equal to 0.05 after performing FDR correction:
selected_pos <- p_corr[p_corr$FDR <= 0.05, 1] %>% 
                  annot_row[.,]
fgenes <- c(unique(selected_pos$UCSC_RefGene_Name)) %>%
               stri_remove_empty(., na_empty = FALSE)

# Handling lines with gene name repetitions:
modify_lines <- function(x) {
      if (grepl(";", x) == TRUE) {
        smatch <- str_match(x, pattern = regex("([a-zA-Z0-9]*);",
                                               ignore_case = T))
        smatch[1, 1] %>% substr(., 1, nchar(.) - 1)
        strsplit(x, ";") # Pakeisti į šį
      } else { x }
}

# Making a unique "foreground" gene name list:
flist <- lapply(fgenes, modify_lines)
fgene_list <- data.table(Genes = unique(unlist(flist)))

write.table(fgene_list, file = "foreground_gene_list.txt", quote = FALSE,
            col.names = FALSE, row.names = FALSE)
```

```{r GO_analysis_all_genes, message=FALSE, warning=FALSE, include=FALSE}
# Extracting 'UCSC_RefGene_Name' column values for the entire positions:
bgenes <- c(unique(annot_row$UCSC_RefGene_Name)) %>%
               stri_remove_empty(., na_empty = FALSE)

# Making a unique "background" gene name list:
blist <- lapply(bgenes, modify_lines)
bgene_list <- data.table(Genes = unique(unlist(blist)))

write.table(bgene_list, file = "background_gene_list.txt", quote = FALSE,
            col.names = FALSE, row.names = FALSE)
```

Suskaičiavus unikalius genus, esančius statistiškai patikimose ir statistiškai
nepatikimose pozicijose, buvo gautas toks genų skaičius:\
- ***`r length(rownames(fgene_list))`*** $\Rightarrow$ genai statistiškai
patikimose pozicijose;\
- ***`r length(rownames(bgene_list))`***` $\Rightarrow$ bendras genų skaičius.

Atlikus Gene Ontology Enrichment analizę su **GOrilla** įrankiu, genai buvo
nagrinėjami pagal tris tipus:\
1. Kokiuose procesuose dalyvauja;\
2. Kokias funkcijas atlieka;\
3. Kokiuose biologiniuose komponentuose (ląstelėse ir pan.) aptinkami.

Žemiau pateikiamoje lentelėje vaizduojami dažniausi procesai, kuriuose dalyvauja
atrinkti genai; dažniausios funkcijos, kurias atlieka baltymus koduojantys
atrinkti genai; komponentai, kuriuose aptinkami atrinktų genų produktai -
baltymai.

### Reikia keisti
```{r GO_analysis_results, echo=FALSE, message=FALSE, warning=FALSE}

GO_results <- read.csv("gene_info.csv") #%>%
                #as.data.table() %>%
                #as_huxtable() %>%
                #set_bold(1, everywhere, TRUE) %>%
                #set_all_borders('NA') %>%
                #set_background_color(1:1, everywhere , "#face2e") %>%
                #set_align(1, 1, "center")

#align(GO_results) <- "center"

GO_results <- GO_results[order(GO_results[, "P_value"]), , drop = FALSE] #Ascending order
print(GO_results)
```
Remiantis lentelėje pateiktais duomenimis bei pilnais ***GOrilla*** analizės
rezultatais galima daryti išvadą, kad didelė dalis genų dalyvauja nervinės
sistemos atliekamuose procesuose. Daug genų produktų - baltymų - įeina į
nervinių ląstelių bei kitų struktūrų (dendritų, sinapsių, ląstelės membraninių
išsikišimų) sudėtį.

# Papildomos užduotys

## 1. GO analizė statistiškai patikimoms ir nepatikimoms pozicijoms

```{r Extra_insignif_signif_positions, message=FALSE, warning=FALSE, include=FALSE}
insignif_pos <- Pval[Pval$P_value > 0.05, 1] %>%
                  annot_row[., ]
ins_genes <- c(unique(insignif_pos$UCSC_RefGene_Name)) %>%
                stri_remove_empty(., na_empty = FALSE)

ins_list <- lapply(ins_genes, modify_lines)
ins_pos_list <- data.table(Genes = unique(unlist(ins_list)))

write.table(ins_pos_list, file = "insignif_pos_gene_list.txt", quote = FALSE,
            col.names = FALSE, row.names = FALSE)
```


```{r Venn_diagram, echo=FALSE, message=FALSE, warning=FALSE}
library(ggvenn)

c(ins_pos_list)
ven <- list(A = c(fgene_list), B = c(ins_pos_list))
a <- unlist(fgene_list)
b <-  unlist(ins_pos_list)
typeof(a)


intersect(b, a)
intersect(a, b)

ven <- list(A = b, B = a)
ggvenn(
  ven, 
  fill_color = c("#0073C2FF", "#EFC000FF"),
  stroke_size = 0.5, set_name_size = 4
  )
```

