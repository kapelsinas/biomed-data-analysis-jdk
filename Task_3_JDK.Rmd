---
title: "Praktinė užduotis Nr. 2"
subtitle: "Klasterizavimas"
author: "Jaroslav Rutkovskij, Danielė Stasiūnaitė, Karolis Augustauskas (JDK)"
date: "4/24/2022"
output: pdf_document
---

```{r Library preparations, include=FALSE}
library(Signac)
library(dplyr)
library(heatmaply)
library(reshape2)
library(ggplot2)
library(data.table)
```

```{r Data_access, include=FALSE}
beta <- readRDS("/home/enjoy/Desktop/dat8.Rds")            # Modification value matrix
pData_col <- readRDS("/home/enjoy/Desktop/pData.Rds")      # Sample (column) matrix
annot_row <- readRDS("/home/enjoy/Desktop/annotation.Rds") # Position (row) matrix
info <- read.csv("/home/enjoy/Documents/GitHub/biomed-data-analysis-jdk/data.csv")
```

# 1. Mėginių hierarchinis klasterizavimas

```{r}
```

# 2. Mėginių atvaizdavimas "heatmap" pavidalu

```{r Task_2_1, include=FALSE}
# Determining unique 'chr' column values (chromosome names) from the matrix
# that describes positions (rows):
chr_names <- unique(annot_row$chr)     
genes_only <- c()

# Loop which checks whether there are common genes between chromosome pairs:
for (i in 1:length(chr_names)) {
  for (y in 1:length(chr_names)) {
    if (i == y) { next }
    else {
      names1 <- annot_row[annot_row$chr == chr_names[i],
                          'UCSC_RefGene_Name'] %>% unique()
      names2 <- annot_row[annot_row$chr == chr_names[y],
                          'UCSC_RefGene_Name'] %>% unique()
      genes <- intersect(names1, names2)
      if (genes[1] == '' & length(genes) == 1) { next }
      else {
        # print(paste0(i, " ir ", y, ": ", genes))
        genes_only <- c(genes_only, genes)
      }
    }
  }
}
```

```{r Task_2_2, include=FALSE}
# Removing empty elements ('') from the gene list:
genes_only <- genes_only[! genes_only %in% c('')]

# Creating gene expression frequency table:
table(genes_only)

gene_list <- c(unique(genes_only))
gene_cnts <- data.frame(chr = chr_names)  # gene_conts --> gene count dataframe
gene_cnts
for (g in 1:length(gene_list)) {
  gene <- c()
  for (j in 1:length(chr_names)) {
    annot_chr <- annot_row[annot_row$chr == chr_names[j], ]
    annot_gene <- annot_chr[annot_chr$UCSC_RefGene_Name == gene_list[g], ] %>% 
                              data.matrix()
    #if (length(annot_gene) == 0) {next}
    # print(paste0(gene_list[g], ", ", chr_names[j], " = ", length(annot_gene)))
    gene <- c(gene, length(annot_gene))
  }
  gene_cnts[ , ncol(gene_cnts) + 1] <- gene
  colnames(gene_cnts)[ncol(gene_cnts)] <- gene_list[g]
}
```

```{r Task_2_3, include=FALSE}
gene_cmt <- data.matrix(gene_cnts)     # gene_cmt --> gene count matrix
gene_cmt <- gene_cmt[ , 2:length(colnames(gene_cmt))]

# fltrd_gene_cnts --> filtered gene count matrix (rows that contained only
# only zero values were removed. It means that gene expression in
# particular chromosome was not identified):
fltrd_gene_cnts <- gene_cmt
rownames(fltrd_gene_cnts) <- c(chr_names)
fltrd_gene_cnts <- fltrd_gene_cnts[rowSums(fltrd_gene_cnts[]) > 0, ]
gene_cnts_melt <- melt(fltrd_gene_cnts)

plot1 <- ggplot(gene_cnts_melt, aes(x = Var2, y = value))+
            geom_bar(stat = 'identity', fill = "#123e68")+
            ylim(0, 1700) +
            facet_wrap(~Var1) +
            labs(title = "Genų ekspresija chromosomose", x = "Genas",
                 y = "Ekspresija") +
            geom_text(aes(label = value), vjust = -0.5, color = "black",
                      size = 3)+
            theme(axis.text.x = element_text(angle = 45, vjust = 0.5),
                  plot.title = element_text(hjust = 0.5, face = "bold"))
plot1
```

Sukūrus aukščiau pavaizduotas stulpelines diagramas buvo nustatyta, kokie genai buvo dažniausi bei kokioje chromosomoje jų buvo daugiausiai.

```{r Task_2_4, include=FALSE}

```

Nuskaitytiems duomenims pritaikyta standartinė ***heatmap()*** funkcija, iliustruojanti **beta** matricos reikšmes ir pagal spalvų intensyvumą bei atspalvį, leidžianti daryti išvadas apie duomenų grupes - klasterius.\
Kadangi **beta** matrica turi ***`r dim(beta)[1]`*** eilutes bei ***`r dim(beta)[2]`*** stulpelius, pavaizduoti visas matricos reikšmes, naudojantis ***heatmap()*** funkcija yra negalima.

# 3. Tikro ir nuspėto amžiaus bei senėjimo "pagreitėjimo" nustatymas

```{r}
#library(BiocManager)
#install(c("tidyverse", "impute", "Rcpp"))
#install.packages("devtools", dependencies = TRUE)

#BiocManager::install("methylclock")
#BiocManager::install("methylclockData")
#library(Biobase)
#library(tibble)
#library(impute)
#library(ggplot2)
#library(ggpmisc)
#library(GEOquery)

library(methylclock)
library(methylclockData)
library(patchwork)

```

Naudojant BioConductor methylClock paketą visiems meginiams yra gaunami DNR modifikacijos laikrodžiai.
Pasirinkti 3 laikrodžiai:
Horvath - developed across multiple tissues
Hannum - blood based
Levine - blood based

```{r}

age.all <- DNAmAge(beta,clocks=c("Horvath", "Hannum", "Levine"))

# Sukuriami objektai kuriuose yra saugomi duomenys apie reikiamia timepoint ir clonic location
vec <- colnames(beta)
info.clean <-info[info$basename %in% vec, ]
info.t1 <- info.clean[info.clean$timepoint == "t1", ]
  info.t1.proximal <- info.t1[info.t1$clonic_location == "proximal", ]
  info.t1.distal <- info.t1[info.t1$clonic_location == "distal", ]
info.t2 <- info.clean[info.clean$timepoint == "t2", ]
  info.t2.proximal <- info.t1[info.t1$clonic_location == "proximal", ]
  info.t2.distal <- info.t1[info.t1$clonic_location == "distal", ]

# Iš age.all objekto istraukiami t1/t2 ir distal/proximal.
vec.t1 <- info.t1.proximal$basename
age.t1.proximal <- age.all[age.all$id %in% vec.t1, ]
vec.t1 <- info.t1.distal$basename
age.t1.distal <- age.all[age.all$id %in% vec.t1, ]

vec.t2 <- info.t2.proximal$basename
age.t2.proximal <- age.all[age.all$id %in% vec.t2, ]
vec.t2 <- info.t2.distal$basename
age.t2.distal <- age.all[age.all$id %in% vec.t2, ]

# Atvaizduojami skirtingi laikrodziai su skirtingais time pointais ir clonic locationais

p1.Horvath.proximal <- plotDNAmAge(age.t1.proximal$Horvath, info.t1.proximal$age, tit = "Horvath method ( proximal ) " )
p1.Horvath.distal <- plotDNAmAge(age.t1.distal$Horvath, info.t2.distal$age, tit = "Horvath method ( distal ) " )

p1.Hannum.proximal <- plotDNAmAge(age.t1.proximal$Hannum, info.t1.proximal$age, tit = "Hannum method ( proximal ) " )
p1.Hannum.distal <- plotDNAmAge(age.t1.distal$Hannum, info.t1.distal$age, tit = "Hannum method ( distal ) " )

p1.Levine.proximal <- plotDNAmAge(age.t1.proximal$Levine, info.t1.proximal$age, tit = "Levine method ( proximal ) " )
p1.Levine.distal <- plotDNAmAge(age.t1.distal$Levine, info.t2.distal$age, tit = "Levine method ( distal ) " )

p2.Horvath.proximal <- plotDNAmAge(age.t2.proximal$Horvath, info.t2.proximal$age, tit = "Horvath method ( proximal ) " )
p2.Horvath.distal <- plotDNAmAge(age.t2.distal$Horvath, info.t2.distal$age, tit = "Horvath method ( distal ) " )

p2.Hannum.proximal <- plotDNAmAge(age.t2.proximal$Hannum, info.t1$age, tit = "Hannum method ( proximal ) " )
p2.Hannum.distal <- plotDNAmAge(age.t2.distal$Hannum, info.t2$age, tit = "Hannum method ( distal ) " )

p2.Levine.proximal <- plotDNAmAge(age.t2.proximal$Levine, info.t1$age, tit = "Levine method ( proximal ) " )
p2.Levine.distal <- plotDNAmAge(age.t2.distal$Levine, info.t2$age, tit = "Levine method ( distal ) " )

p1.Horvath.proximal + p1.Horvath.distal +
  p1.Hannum.proximal + p1.Hannum.distal +
  p1.Levine.proximal + p1.Levine.distal +
    plot_layout(ncol = 2)

p2.Horvath.proximal + p2.Horvath.distal +
  p2.Hannum.proximal + p2.Hannum.distal +
  p2.Levine.proximal + p2.Levine.distal +
    plot_layout(ncol = 2)

```

Parodoma visų trijų laikrodžių koreliacija.

```{r}

age.GSE <- DNAmAge(beta,clocks=c("Horvath", "Hannum","Levine"), age = info.clean$age)



plotCorClocks(age.GSE)

```



```{r}


tit = "Horvath method"

df <- data.frame(x = age.all$Horvath, y = info.clean$age, aspirin = info.clean$aspirin)
my.formula <- y ~ x
yy <- "Chronological Age"
  p <- ggplot2::ggplot(data = df, ggplot2::aes(x = x, y = y)) + 
    ggplot2::geom_smooth(method = "lm", se = FALSE, color = "black", 
      formula = my.formula) + ggplot2::xlab("DNA Methylation Age") + 
    ggplot2::ylab(yy) + ggplot2::ggtitle(tit) + 
    ggplot2::aes(x, y, colour = aspirin) + ggplot2::geom_point()
p

```




