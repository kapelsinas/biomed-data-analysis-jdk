---
title: "Praktinė užduotis Nr. 2"
subtitle: "Klasterizavimas"
author: "Jaroslav Rutkovskij, Danielė Stasiūnaitė, Karolis Augustauskas (JDK)"
date: "4/24/2022"
output: pdf_document
---
```{r Library_preparations, include=FALSE}
library(pacman)
p_load(Signac, dplyr, heatmaply, reshape2, ggplot2, data.table, matrixStats,
       WGCNA, ggpubr)
library(ggpubr)
```

```{r Data_access, include=FALSE}
beta <- readRDS("dat8.Rds")               # Modification value matrix
pData_col <- readRDS("pData.Rds")         # Sample (column) matrix
annot_row <- readRDS("annotation.Rds")    # Position (row) matrix
```

Prieš atliekant duomenų hierarchinį klasterizavimą buvo sukurti nauji
mėginių pavadinimai, pakeičiant originalius pavadinimus, kurie buvo ilgi ir
neinformatyvūs. Pavadinimai buvo pakeisti, vadovaujantis žemiau aprašytu
principu:\
            
1. Nurodomas donoro numeris. Pvz.: ***n37***.\
2. Po apatinio brūkšnio nurodomas laikas, kada buvo imta biopsija (gali
būti ***t1*** arba ***t2***, kur ***t1*** nurodo, kad biopsija buvo imta pirmaisiais
metais, o ***t2*** nurodo, kad biopsija buvo paimta praėjus 10 metų po
pirmosios procedūros).\
3. Po apatinio brūkšnio nurodoma, iš kurios žarnos (proksimalinės ar
distalinės) buvo imama biopsija. Žarnų tipai užrašomi sutrumpinus pilnus
pavadinimus iki keturių raidžių:\
**proximal** \(\Rightarrow\) ***prox***, **distal** \(\Rightarrow\) ***dist***.\
4. Po apatinio brūkšnio trijų raidžių kombinacija nurodoma, ar tiriamasis
vartojo aspiriną: ***nnu*** \(\Rightarrow\)
**aspirinas nevartojamas (non-user)**, ***lng*** \(\Rightarrow\)
**aspirinas vartojamas (longterm user)**.\
5. Po apatinio brūkšnio nurodomas moters amžius.\
    
Pilnas naujai sukurto pavadinimo pavyzdys: ***n10_t1_prox_nnu_55***, kur:\
- **n10** - donoro numeris;
- **t1** - biopsija imta pirmaisiais tyrimo metais;
- **prox** - mėginys gautas iš proksimalinės žarnos;
- **nnu** - tiriamasis nevartojo asprino;
- **55** - tiriamojo amžius.

```{r Filename_generation, include=FALSE}
samples <- read.table("samples.txt", header = TRUE) %>% setDT()
samples[, graph_name := paste0("n", samples$donor, "_", samples$timepoint, "_",
                               substring(samples$clonic_location, 1, 4), "_",
                               paste0(substring(samples$aspirin, 1, 1),
                                      substring(samples$aspirin, 3, 4)), "_",
                               samples$age)]
```

# 1. Mėginių hierarchinis klasterizavimas
```{r}
```

# 2. Mėginių atvaizdavimas "heatmap" pavidalu
Kadangi **beta** matrica turi ***`r dim(beta)[1]`*** eilutes bei
***`r dim(beta)[2]`*** stulpelius, pavaizduoti visas matricos reikšmes bei,
atsižvelgus į spalvų intensyvumą ir atspalvį, daryti išvadas apie duomenų
grupes - klasterius, naudojantis ***heatmap()*** funkcija yra negalima, iš
eilutes aprašančios matricos buvo atrinktos tik tam tikros eilutės.\

**Eilučių atrinkimas buvo atliktas, remiantis žemiau pažingsniui aprašyta **
**logika:**\

1. Iš pradžių iš eilutes aprašančios matricos buvo surasti genai (jų
pavadinimai, remiantis eilutes aprašančios matricos 'UCSC_RefGene_Name'
stulpeliu), kurie pasikartodavo tarp dviejų chromosomų. Gauti bendrų
genų dažniai pavaizduoti lentele:

```{r Task_2_1, echo=FALSE, message=FALSE, warning=FALSE}
# Determining unique 'chr' column values (chromosome names) from the matrix
# that describes positions (rows):
chr_names <- unique(annot_row$chr)     
genes_only <- c()

# Loop which checks whether there are common genes between chromosome pairs:
for (i in 1:length(chr_names)) {
  for (y in 1:length(chr_names)) {
    if (i == y) { next }
    else {
      names1 <- annot_row[annot_row$chr == chr_names[i],
                          'UCSC_RefGene_Name'] %>% unique()
      names2 <- annot_row[annot_row$chr == chr_names[y],
                          'UCSC_RefGene_Name'] %>% unique()
      genes <- intersect(names1, names2)
      if (genes[1] == '' & length(genes) == 1) { next }
      else {
        # print(paste0(i, " ir ", y, ": ", genes))
        genes_only <- c(genes_only, genes)
      }
    }
  }
}

# Removing empty elements ('') from the gene list:
genes_only <- genes_only[! genes_only %in% c('')]

# Creating gene expression frequency table:
print(table(genes_only))
```

2. Turint dažnius buvo suformuotas objektas, suskaičiuojantis
konkrečių genų dažnius chromosomose.

```{r Task_2_2, echo=FALSE}
gene_list <- c(unique(genes_only))
gene_cnts <- data.frame(chr = chr_names)  # gene_conts --> gene count dataframe

for (g in 1:length(gene_list)) {
  gene <- c()
  for (j in 1:length(chr_names)) {
    annot_chr <- annot_row[annot_row$chr == chr_names[j], ]
    annot_gene <- annot_chr[annot_chr$UCSC_RefGene_Name == gene_list[g], ] %>% 
                              data.matrix()
    #if (length(annot_gene) == 0) {next}
    # print(paste0(gene_list[g], ", ", chr_names[j], " = ", length(annot_gene)))
    gene <- c(gene, length(annot_gene))
  }
  gene_cnts[ , ncol(gene_cnts) + 1] <- gene
  colnames(gene_cnts)[ncol(gene_cnts)] <- gene_list[g]
}
```

3. Iš matricos (ji buvo gauta iš data.frame objekto) buvo pašalintos
eilutės (chromosomos), kuriose nebuvo nustatytas nei vienas genas (visos
reikšmės eilutėje buvo lygios 0), ir buvo sukurtos stulpelinės diagramos,
vizualizuojančios, kokiose chromosomose tam tikro geno buvo nustatyta
daugiausiai.
    
Modifikacijos įverčiams atvaizduoti heatmap pavidalu buvo pasirinkta
chromosoma, turinti didžiausią tam tikro geno raišką.

```{r Task_2_3, echo=FALSE, warning=FALSE}
gene_cmt <- data.matrix(gene_cnts)     # gene_cmt --> gene count matrix
gene_cmt <- gene_cmt[ , 2:length(colnames(gene_cmt))]

# fltrd_gene_cnts --> filtered gene count matrix (rows that contained only
# only zero values were removed. It means that gene expression in
# particular chromosome was not identified):
fltrd_gene_cnts <- gene_cmt
rownames(fltrd_gene_cnts) <- c(chr_names)
fltrd_gene_cnts <- fltrd_gene_cnts[rowSums(fltrd_gene_cnts[]) > 0, ]
gene_cnts_melt <- reshape2::melt(fltrd_gene_cnts)

plot1 <- ggplot(gene_cnts_melt, aes(x = Var2, y = value))+
            geom_bar(stat = 'identity', fill = "#123e68")+
            ylim(0, 1700) +
            facet_wrap(~Var1) +
            labs(title = "Genų ekspresija chromosomose", x = "Genas",
                 y = "Ekspresija") +
            geom_text(aes(label = value), vjust = -0.5, color = "black",
                      size = 3)+
            theme(axis.text.x = element_text(angle = 45, vjust = 0.5),
                  plot.title = element_text(hjust = 0.5, face = "bold"))
plot1
```

Remiantis aukščiau pavaizduotų stulpelinių diagramų duomenimis, **heatmap**
buvo pasirinkta atvaizduoti **8 chromosomos** ir ***MIR1268A geno***
modifikacijos duomenis.\

```{r Task_2_4, include=FALSE}
chr <- "chr8"
gene <- "MIR1268A"

# Extracting rows from 'annotation' matrix that describe 8th chromosome:
slctd_chr <- annot_row[annot_row$chr == chr, ] 

# Extracting rows from the 'slctd_chr' matrix which has 'MIR1268A' values
# described in 'UCSC_RefGene_Name' column:
slctd_gene <- slctd_chr[slctd_chr$UCSC_RefGene_Name == gene, ] %>%
                  data.matrix()

# Selecting values from the main modification matrix - beta matrix based on
# the 'slctd_gene' matrix rownames:
beta_slctd_gene <- (beta[rownames(slctd_gene), ])

# mlt <- reshape2::melt(beta_slctd_gene)
# mlts <- reshape2::melt((beta_slctd_gene - rowMeans(beta_slctd_gene)) /
#                    rowSds(beta_slctd_gene))

# heatmap(beta_slctd_gene)
# heatmap((beta_slctd_gene - rowMeans(beta_slctd_gene)) /
#                    rowSds(beta_slctd_gene))

# plot2 <- ggplot(mlt, aes(Var2, Var1, fill= value)) + 
#   geom_tile()

# plot3 <- ggplot(mlts, aes(Var2, Var1, fill= value)) + 
#   geom_tile()

# ggarrange(plot2, plot3, labels = c("Prieš normalizavimą", "Po normalizavimo"),
#           ncol = 1, nrow = 2)
#png(file = "heatmap_nnorm.png")
#heatmap(beta_slctd_gene)
#dev.off()

#png(file = "heatmap_norm.png")
#heatmap((beta_slctd_gene - rowMeans(beta_slctd_gene)) / rowSds(beta_slctd_gene))
#dev.off()
```


```{r Task_2_5, include=FALSE}
#distance <- dist(beta_slctd_gene, method = "euclidean")
#hc <- hclust(distance, method = "complete")
#colorss <- numbers2colors(distance)
#plot(hc)
#plotDendroAndColors(hclust(distance, method = "ward"), colorss)
```




# 3. Tikro ir nuspėto amžiaus bei senėjimo "pagreitėjimo" nustatymas
```{r}
```
