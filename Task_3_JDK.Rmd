---
title: "Praktinė užduotis Nr. 2"
author: "Jaroslav Rutkovskij, Danielė Stasiūnaitė, Karolis Augustauskas (JDK)"
date: "4/24/2022"
output:
  pdf_document: default
subtitle: Klasterizavimas
---

```{r Library_preparations, warning=FALSE, include=FALSE}
library(pacman)
p_load(Signac, dplyr, heatmaply, reshape2, ggplot2, data.table, matrixStats,
       WGCNA, ggpubr, ComplexHeatmap, hrbrthemes, dendextend, RColorBrewer,
       Heatplus, gplots, heatmap3, matrixStats)
```

```{r Data_access, warning=FALSE, include=FALSE}
beta <- readRDS("dat8.Rds")               # Modification value matrix
pData_col <- readRDS("pData.Rds")         # Sample (column) matrix
annot_row <- readRDS("annotation.Rds")    # Position (row) matrix
```

## Pagrindinės užduotys

Prieš atliekant duomenų hierarchinį klasterizavimą buvo sukurti nauji mėginių
pavadinimai, pakeičiant originalius pavadinimus, kurie buvo ilgi ir
neinformatyvūs. Pavadinimai buvo pakeisti, vadovaujantis žemiau aprašytu
principu:

1. Nurodomas donoro numeris. Pvz.: ***n37***.

2. Po apatinio brūkšnio nurodomas laikas, kada buvo imta biopsija (gali būti
***t1*** arba ***t2***, kur ***t1*** nurodo, kad biopsija buvo imta pirmaisiais
metais, o ***t2*** nurodo, kad biopsija buvo paimta praėjus 10 metų po
pirmosios biopsijos ėmimo).

3. Po apatinio brūkšnio nurodoma, iš kurios žarnos (proksimalinės ar
distalinės) buvo imama biopsija. Žarnų tipai užrašomi sutrumpinus pilnus
pavadinimus iki keturių raidžių:\
**proximal** $\Rightarrow$ ***prox***,\
**distal** $\Rightarrow$ ***dist***.

4. Po apatinio brūkšnio trijų raidžių kombinacija nurodoma, ar tiriamasis
vartojo aspiriną:\
***nnu*** $\Rightarrow$ **aspirinas nevartojamas (non-user)**,\
***lng*** $\Rightarrow$ **aspirinas vartojamas (longterm user)**.

5. Po apatinio brūkšnio nurodomas moters amžius.

Pilnas naujai sukurto pavadinimo pavyzdys: ***n10_t1_prox_nnu_55***, kur:

 - **n10** - donoro numeris;
 - **t1** - biopsija imta pirmaisiais tyrimo metais;
 - **prox** - mėginys gautas iš proksimalinės žarnos;
 - **nnu** - tiriamasis nevartojo asprino;
 - **55** - tiriamojo amžius.

Mėginių vardų pavyzdys realiems duomenims:

```{r Filename_generation, echo=FALSE, warning=FALSE}
samples <- read.table("samples.txt", header = TRUE) %>% setDT()
samples[, graph_name := paste0("n", samples$donor, "_", samples$timepoint, "_",
                               substring(samples$clonic_location, 1, 4), "_",
                               paste0(substring(samples$aspirin, 1, 1),
                                      substring(samples$aspirin, 3, 4)), "_",
                               samples$age)]
colnames(beta) <- samples$graph_name[match(colnames(beta), samples$Basename)]
head(beta[, 1:2], n = 3)
write.csv(samples, "samples2.csv")
```

# 1. Mėginių hierarchinis klasterizavimas

```{r}
```

# 2. Mėginių atvaizdavimas "heatmap" pavidalu

Kadangi **beta** matrica turi ***`r dim(beta)[1]`*** eilutes bei
***`r dim(beta)[2]`*** stulpelius, pavaizduoti visas matricos reikšmes bei,
atsižvelgus į spalvų intensyvumą ir atspalvį, daryti išvadas apie duomenų
grupes - klasterius, naudojantis ***heatmap()*** funkcija yra negalima,
iš eilutes aprašančios matricos buvo atrinktos tik tam tikros eilutės.

**Eilučių atrinkimas buvo atliktas, remiantis žemiau pažingsniui aprašyta**
**logika:**

1. Iš pradžių iš eilutes aprašančios matricos buvo surasti genai (jų
pavadinimai, remiantis eilutes aprašančios matricos 'UCSC_RefGene_Name'
stulpeliu), kurie pasikartodavo tarp dviejų chromosomų. Gauti bendrų genų
dažniai pavaizduoti lentele:

```{r Task_2_1, echo=FALSE, message=FALSE, warning=FALSE}
# Determining unique 'chr' column values (chromosome names) from the matrix
# that describes positions (rows):
chr_names <- unique(annot_row$chr)     
genes_only <- c()

# Loop which checks whether there are common genes between chromosome pairs:
for (i in 1:length(chr_names)) {
  for (y in 1:length(chr_names)) {
    if (i == y) { next }
    else {
      names1 <- annot_row[annot_row$chr == chr_names[i],
                          'UCSC_RefGene_Name'] %>% unique()
      names2 <- annot_row[annot_row$chr == chr_names[y],
                          'UCSC_RefGene_Name'] %>% unique()
      genes <- intersect(names1, names2)
      if (genes[1] == '' & length(genes) == 1) { next }
      else {
        # print(paste0(i, " ir ", y, ": ", genes))
        genes_only <- c(genes_only, genes)
      }
    }
  }
}

# Removing empty elements ('') from the gene list:
genes_only <- genes_only[! genes_only %in% c('')]

# Creating gene expression frequency table:
print(table(genes_only))
```

2. Turint dažnius buvo suformuotas objektas, suskaičiuojantis konkrečių genų
dažnius chromosomose.

```{r Task_2_2, echo=FALSE}
gene_list <- c(unique(genes_only))
gene_cnts <- data.frame(chr = chr_names)  # gene_conts --> gene count dataframe

for (g in 1:length(gene_list)) {
  gene <- c()
  for (j in 1:length(chr_names)) {
    annot_chr <- annot_row[annot_row$chr == chr_names[j], ]
    annot_gene <- annot_chr[annot_chr$UCSC_RefGene_Name == gene_list[g], ] %>% 
                              data.matrix()
    #if (length(annot_gene) == 0) {next}
    # print(paste0(gene_list[g], ", ", chr_names[j], " = ", length(annot_gene)))
    gene <- c(gene, length(annot_gene))
  }
  gene_cnts[ , ncol(gene_cnts) + 1] <- gene
  colnames(gene_cnts)[ncol(gene_cnts)] <- gene_list[g]
}
```

3.  Iš matricos (ji buvo gauta iš data.frame objekto) buvo pašalintos eilutės
(chromosomos), kuriose nebuvo nustatytas nei vienas genas (visos reikšmės
eilutėje buvo lygios 0), ir buvo sukurtos stulpelinės diagramos,
vizualizuojančios, kokiose chromosomose tam tikro geno buvo nustatyta
daugiausiai.

Modifikacijos įverčiams atvaizduoti ***heatmap*** pavidalu buvo pasirinkta
chromosoma, turinti didžiausią tam tikro geno raišką.

```{r Task_2_3, echo=FALSE, warning=FALSE}
gene_cmt <- data.matrix(gene_cnts)     # gene_cmt --> gene count matrix
gene_cmt <- gene_cmt[ , 2:length(colnames(gene_cmt))]

# fltrd_gene_cnts --> filtered gene count matrix (rows that contained only
# only zero values were removed. It means that gene expression in
# particular chromosome was not identified):
fltrd_gene_cnts <- gene_cmt
rownames(fltrd_gene_cnts) <- c(chr_names)
fltrd_gene_cnts <- fltrd_gene_cnts[rowSums(fltrd_gene_cnts[]) > 0, ]
gene_cnts_melt <- reshape2::melt(fltrd_gene_cnts)

plot1 <- ggplot(gene_cnts_melt, aes(x = Var2, y = value))+
            geom_bar(stat = 'identity', fill = "#123e68")+
            ylim(0, 1700) +
            facet_wrap(~Var1) +
            labs(title = "Gene expression", x = "Gene",
                 y = "Expression") +
            geom_text(aes(label = value), vjust = -0.5, color = "black",
                      size = 3) +
            theme(axis.text.x = element_text(angle = 45, vjust = 0.5),
                  plot.title = element_text(hjust = 0.5, face = "bold"))
print(plot1)
```

Remiantis aukščiau pavaizduotų stulpelinių diagramų duomenimis, ***heatmap***
buvo pasirinkta atvaizduoti **9 chromosomos** ir ***MIR1268A geno***
modifikacijos duomenis.

```{r Task_2_4, warning=FALSE, include=FALSE}
chr <- "chr9"
gene <- "MIR1268A"

# Extracting rows from 'annotation' matrix that describe 8th chromosome:
slctd_chr <- annot_row[annot_row$chr == chr, ] 

# Extracting rows from the 'slctd_chr' matrix which has 'MIR1268A' values
# described in 'UCSC_RefGene_Name' column:
slctd_gene <- slctd_chr[slctd_chr$UCSC_RefGene_Name == gene, ] %>%
                  data.matrix()

# Selecting values from the main modification matrix - beta matrix based on
# the 'slctd_gene' matrix rownames:
beta_slctd_gene <- (beta[rownames(slctd_gene), ])
normalized_beta <- (beta_slctd_gene - rowMeans(beta_slctd_gene)) /
                        rowSds(beta_slctd_gene)

timepoint <- unlist(lapply(colnames(beta_slctd_gene), function(x) {
  if(grepl("t1", x)) '#0D2855'         # dark blue
  else if(grepl("t2", x)) '#3471DA'    # light blue
}))

clonic_lct <- unlist(lapply(colnames(beta_slctd_gene), function(x) {
  if(grepl("dist", x)) '#7D0F1A'       # dark red
  else if(grepl("prox", x)) '#FD2E43'  # light red
}))

aspirin <- unlist(lapply(colnames(beta_slctd_gene), function(x) {
  if(grepl("lng", x)) '#2E5F15'        # dark green
  else if(grepl("nnu", x)) '#5EDA21'   # light green
}))

ages <- samples$age
color_options <- labels2colors(ages)

age_colors <- unlist(lapply(colnames(beta_slctd_gene), function(x) { 
for (age in 1:length(colnames(beta_slctd_gene))) {
  if(grepl(paste0("_", ages[age]), x)) return(color_options[age])
  #print(paste(ages[age], "-->", color_options[age]))
}
}))

annotation_col <- cbind(timepoint, clonic_lct, aspirin, age_colors)
```

\pagebreak

Žemiau atvaizduojami modifikacijos įverčiai ***heatmap*** grafiko pavidalu
prieš atliekant normalizavimą:

```{r Task_2_5, echo=FALSE, message=FALSE, warning=FALSE}
heatmap3(beta_slctd_gene, col = magma(length(beta_slctd_gene)),
         cexRow = 0.8, cexCol = 0.5, margins = c(10, 5), scale = "row",
         ColSideColors = annotation_col, showRowDendro = F,
         main = "Representation of modification values before normalization",
         distfun = function(x) as.dist(1 - cor(t(x), use = "pa")),
         method = "complete", hclustfun = hclust,
         legendfun = function(x) plot.new())

legend("left", legend = c("t1 - first year", "t2 - after 10 years",
                              "distal colon", "proximal colon",
                              "longterm user", "non-user"),
       col = c("#0D2855", "#3471DA", "#7D0F1A", "#FD2E43", "#2E5F15",
               "#5EDA21"), lty= 1, lwd = 10, bty = "n", cex = 0.6,
       title = "Color meanings")
```

Žemiau atvaizduojami modifikacijos įverčiai ***heatmap*** grafiko pavidalu
atlikus normalizavimą:

```{r Task_2_6, echo=FALSE, message=FALSE, warning=FALSE}
heatmap3(normalized_beta, col = magma(length(normalized_beta)),
         cexRow = 0.8, cexCol = 0.5, margins = c(10, 5), scale = "row",
         ColSideColors = annotation_col, showRowDendro = F,
         main = "Representation of modification values after normalization",
         distfun = function(x) as.dist(1 - cor(t(x), use = "pa")),
         method = "complete", hclustfun = hclust,
         legendfun = function(x) plot.new())

legend("left", legend = c("t1 - first year", "t2 - after 10 years",
                              "distal colon", "proximal colon",
                              "longterm user", "non-user"),
       col = c("#0D2855", "#3471DA", "#7D0F1A", "#FD2E43", "#2E5F15",
               "#5EDA21"), lty= 1, lwd = 10, bty = "n", cex = 0.6,
       title = "Color meanings")
```

Apibendrinus gautus rezultatus galima padaryti išvadą, kad net ir sumažinus
modifikacijos pozicijų skaičių, nagrinėjant tik devintos chromosomos
***MIR1268A*** geną, negalima įžvelgti aiškių grupių, kurios gali būti
analizuojamos toliau, ieškant bendrumų tarp grupės objektų.

Siekiant gauti ***heatmap*** grafiką, kuriame galima matyti aiškiai
susidariusias grupes (klasterius), buvo nuspręsta iš modifikacijos įverčių
matricos atrinkti 30 variabiliausių pozicijų ir sukurti **heatmap** grafiką
būtent šioms pozicijoms, pavaizduojant ***heatmap*** grafikus prieš atliekant
normalizavimą bei atlikus jį.

```{r Task_2_7, echo=FALSE, message=FALSE, warning=FALSE}
beta_nw <- as.data.frame(beta)
beta_nw$row_var = rowVars(as.matrix(beta_nw[, c(-1)]))

beta_var <- tail(beta_nw[order(beta_nw$row_var), ], n = 30)
beta_var$row_var <- NULL

beta_norm_var <- (data.matrix(beta_var) - rowMeans(data.matrix(beta_var))) /
                              rowSds(data.matrix(beta_var))

col_rnorm = colorRamp2(c(-3, 0, 3), c("#FFFFFF", "#62A5F2", "#073366"))

h1 <- Heatmap(data.matrix(beta_var), cluster_rows = TRUE, col = col_rnorm,
              cluster_columns = FALSE, show_heatmap_legend = FALSE,
              show_column_names = FALSE,
              column_title = "Before standardization")

h2 <- Heatmap(beta_norm_var, cluster_rows = TRUE, col = col_rnorm,
              cluster_columns = FALSE, column_title = "After standardization",
              show_column_names = FALSE,
              heatmap_legend_param = list(title = "Color key"))

plot(h1+h2)
```

Aukščiau pavaizduotuose ***heatmap*** grafikuose aiškiai matomas spalvų
pasikeitimas, atlikus modifikacijos pozicijų normalizavimą taip, jog eilučių
vidurkis būtų lygus 0, o standartinis nuokrypis būtų lygus 1.

Remiantis "Color key" skale galima pastebėti, jog modifikacijos pozicijos,
kurios prieš atliekant standartizavimą buvo vizualizuojamos šviesesne spalva,
atlikus standartizavimą buvo pavaizduotos dar šviesesne spalva (reikšmės buvo
sumažintos). Tuo tarpu modifikacijos pozicijos, kurios prieš normalizavimą buvo
vaizduojamos tamsesne spalva, po normalizavimo įgijo dar didesnę reikšmę ir
buvo atvaizduotos dar tamsesne spalva.

# 3. Tikro ir nuspėto amžiaus bei senėjimo "pagreitėjimo" nustatymas

```{r}
```

## Papildomos užduotys

### 1. t-SNE klasterizavimo metodo pritaikymas

```{r Extra_1, echo=FALSE, message=FALSE, warning=FALSE}

```
